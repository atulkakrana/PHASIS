#!/usr/local/bin/python3

## phastrigs: identifies miRNA triggers for phased loci/precursors 
## updated  : version-1.03 04/04/2017
## Author   : kakrana@udel.edu

## Copyright (c): 2016, by University of Delaware
##              Contributor : Atul Kakrana
##              Affilation  : Meyers Lab (Donald Danforth Plant Science Center, St. Louis, MO)
##              License copy: Included with PHASIS and could be found at https://opensource.org/licenses/Artistic-2.0


import sys,os,re,time,timeit,datetime,csv,glob,string,shutil,operator,argparse,re,importlib,collections
import subprocess, multiprocessing
from multiprocessing import Process, Queue, Pool
from operator import itemgetter
from os.path import expanduser

#########################################################################
#### USER SETTINGS ######################################################

setFile         = "phasis.set"         ### Settings file from phaser analysis
memFile         = "phasmerge.mem"      ### Memory file from collapser  
res_folder      = "triggers_%s"   % (datetime.datetime.now().strftime("%m_%d_%H_%M"))
home            = expanduser("~")
phaster_path    = "%s/.phasis" % (home)

##### DEVELOPER OPTIONS ##########
nthread         = 6                                         ## Need automatic calculation like nProc
nproc           = "Y"                                       ## Used by parallel processing

#### validatePAREby PHAS settings
PAREpval        = 0.25                                      ## Only if PAREresType == 'S' - Cutoff of corrected p-value to
                                                            ## use to filter out non-relevant predictions

offset          = 1                                         ## 0: No +1/-1 phases scanned 1: In addition to phase, the +1/-1 sites also checked for trigger


### ARGUMENTS ###########################################################
#########################################################################

parser      = argparse.ArgumentParser()

reqflags    = parser.add_argument_group("required arguments")
autoflags   = parser.add_argument_group("Arguments required for --auto (matic) mode") ## Add required arguments to this group and optional to parser
manflags    = parser.add_argument_group("Arguments required for --man (ual) mode") ## Add required arguments to this group and optional to parser

reqflags.add_argument('-mode', default='auto', help=
    'auto: For automatic trigger identification  | man: to use user predicted targets and '\
    'user supplied values for -coord, -predtype, -predfile and -phas parameter',required=True)

reqflags.add_argument('-dir',  default='', type=str, help='directory from your '\
    'collapser run for which triggers need to be identified. Required parameter', required=True)

parser.add_argument('-score', default='7', type=float, help='target score cutoff for '\
    'predicted targets to be used for trigger identification. Optional parameter', required=False )

parser.add_argument('-searchspace', default=5, type=int, help=' defines the search space '\
    'to scan for triggers. Provide input in ‘PHAS index’ (PI), which is defined as theoretical '\
    'phased positions upstream and downstream from the 5’ terminus of P1. Input PI value '\
    'between 1 and 8. 1 being most stringent and 8 being most relaxed. The results from relaxed '
    ' setting can be filtered later in result file. Optional parameter', required=False )

#### For manual prediction
manflags.add_argument('-coord', default='', type=str, help='concatanated file from '\
    'all_coords generated by sPARTA from genic and intergenic target prediction')

manflags.add_argument('-predtype', default='P', type=str, help='predicted or PARE validated '\
    'miRNA targets from sPARTA. P: For predicted | D: Degradome validated')

manflags.add_argument('-predfile', default='', type=str, help='concatanated file from ' \
    'All.targs.parsed files generated by sPARTA from genic and intergenic target prediction')

# manflags.add_argument('-phas', default='', type=str, help=' path to collapsed file generated'\
#     'by the collapser script from phasTER phased loci prediction analysis')

#### For automatic prediction
autoflags.add_argument('-mir',  default='', type=str, help='miRNA file (name) in FASTA format '\
    'that will be used to as query to check for triggers')

autoflags.add_argument('-libs',  nargs='*', default=[], help='PARE or degradome libraries in '\
    'FASTA or flat file format that will be used to validate PHAS triggers. Multiple libraries '\
    ' names can be seprated by a empty space. Flat file should have unique PARE seqeunces and '\
    ' their counts in tab separated format. Optional parameter')

args = parser.parse_args()

#### SANITY CHECKS ##########################################
#############################################################
#### For automatic mode
if args.mode == "auto":
    
    #### Set required parameters
    args.coord      = ''

    # print (args.libs)
    # sys.exit()
    
    if args.libs: ### It is a list
        args.predtype = 'D'     ## Validation needs to be done
        args.predfile = "%s/sparta/output/All.libs.validated.uniq.csv" % (res_folder)

    else:
        args.predtype = 'P'     ## Prediction nees to be done
        args.predfile = "%s/sparta/predicted/All.targs.parsed.csv" % (res_folder)     ## Will be updated by sPARTA run

    #### clean-up PHASER directory 
    if args.dir.endswith("/"):
        args.dir = args.dir[0:-1]                                                            ## Not required for this mode

    #### Check for required parameters
    if not args.dir:
        print("\n** Directory with collapsed results not provided for 'automatic' trigger prediction")
        print("** Please use and provide a value for '-dir' switch")
        print("** script will exit now, run 'python3 phastrigs --help' for more info\n")
        sys.exit()

    else:
        ### Collapser directory provided, chekc for miRNAs file
        if not args.mir:
            print("\n** miRNA (FASTA) file name not provided for 'automatic' trigger prediction")
            print("** Please use and provide a value for '-mir' switch")
            print("** script will exit now, run 'python3 phastrigs --help' for more info\n")
            sys.exit()
        else:
            pass

#### For manual mode
elif args.mode == "man":

    if not args.dir:
        print("\n** Directory with collapsed results not provided for 'manual' mode of trigger")
        print("** Identification - please use and provide a value for '-dir' switch")
        print("** script will exit now, run 'python3 phastrigs --help' for more info\n")
        sys.exit()
    
    ####
    if args.dir:
        args.valid = True
        if args.dir.endswith("/"):
            args.dir = args.dir[0:-1]

    ####
    if not args.dir:
        if args.predfile:
            print("\n** File from collapser not provided so only the processing of target prediction "\
                "or validation file will be performed")
            time.sleep(2)
        elif not args.predfile:
            print("\n** Please provide inputs for '-pred' and '-phas' parameters")
            print("** script will exit now, run 'python3 phastrigs --help' for more info\n")
            sys.exit()
        else:
            pass
    else:
        pass

else:
    print("Please provide correct values for '-mode' parameter")
    print("%s is not a valid option" % (args.mode))
    print("Valid options are '-auto' and '-man'")
    print("For more information run: python3 phastrigs --help")
    sys.exit()

### FUNCTIONS ###############################################
#############################################################

def checkDependency():
    '''Checks for required components on user system'''

    print("\n#### Fn: checkLibs ###########################")
    
    goSignal    = True ### Signal to process is set to true 

    ### Check sPARTA
    issPARTA    = os.path.isfile("%s/sPARTA.py" % (phaster_path))
    if issPARTA is False:
        print("--sPARTA                         : missing")
        goSignal    = False
    else:
        print("--sPARTA                         : found")
        pass

    ### Check bowtie2
    isbowtie2 = shutil.which("bowtie2")
    if isbowtie2:
        print("--Bowtie2                        : found")
        pass
    else:
        print("--Bowtie2                        : missing")
        goSignal    = False
        # print("See README for how to INSTALL")

    if args.mode == 'auto':
        ## Check scipy
        isScipy     = importlib.find_loader('scipy')
        if isScipy is None:
            print("--scipy                          : missing")
            goSignal    = False
        else:
            print("--scipy                          : found")
            pass

        isNumpy     = importlib.find_loader('numpy')
        if isNumpy is None:
            print("--numpy                          : missing")
            goSignal    = False
        else:
            print("--numpy                          : found")
            pass


    if goSignal == False:
        print("\n** Please install missing libraries before running the analyses")
        # print("See README for how to install these")
        print("** phastrigs has unmet dependendies and will exit for now\n")
        sys.exit()

    return None

def readSet(setFile):
    '''
    Read and parse external settings file
    '''

    if os.path.isfile(setFile):
        pass
    else:
        print("---Settings file 'prepro.set' not found in current directory")
        print("---Please copy it to same directory as script and rerun")
        sys.exit()

    print("\n#### Fn: Settings Reader #####################")
    
    fh_in   = open(setFile, 'r')
    setFile = fh_in.readlines()
    fh_in.close()
    
    for line in setFile:
        if line: ## Not empty
            if line.startswith('@'):
                line = line.strip("\n")
                # print(line)
                akey,aval = line.split('=')
                param = akey.strip()
                value = aval.strip()
                # print(param,value)
                
                ## Extract values ######### 

                if param.strip() == '@runType':
                    global runType
                    runType = str(value.strip())
                    if (runType != "G") and (runType != "T") and (runType != "S"):
                        print("Please input correct setting for '@runType' parameter in 'phasis.set' file")
                        print("Script will exit for now\n")
                        sys.exit()
                    else:
                        print('User Input runType               :',runType)

                elif param.strip() == '@index':
                    global index
                    index = str(value.strip())
                    print('User Input index location        :',index)

                elif param.strip() == '@db':
                    global db
                    db = str(value.strip())
                    print('User Input sRNA DB               :',db)

                elif param.strip() == '@fetchLib':
                    global fetchLib
                    fetchLib = str(value.strip())
                    print('User Input to auto fetch libs    :',fetchLib)

                elif param.strip() == '@userLibs':
                    global libs
                    libs = list(map(str,value.strip().split(',')))
                    print('User Input Libs                  :',",".join(libs))

                elif param.strip() == '@reference':
                    global reference
                    reference = str(value.strip())
                    print('User Input reference             :',reference)

                elif param.strip() == '@phase':
                    global phase
                    phase = int(value.strip())
                    print('User Input for phase length      :',phase)
                
                elif param.strip() == '@path_prepro_git':
                    global phaster_path
                    phaster_path = str(value.strip()).rstrip("/")+"/phaster"
                    print('User Input for phaster path      :',phaster_path) 

            else:
                #print("Missed line:",line)
                pass
    # sys.exit()
    return libs

def readMem(memFile):
    '''
    Reads memory file and gives global variables
    '''
    print ("\n#### Fn: memReader ##########################")
    fh_in   = open(memFile,'r')
    memRead = fh_in.readlines()
    fh_in.close()

    for line in memRead:
        if line: ## Not empty
            if line.startswith('@'):
                line        = line.strip("\n")
                # print(line)
                akey,aval   = line.split(':')
                param       = akey.strip()
                value       = aval.strip()
                # print(param,value)

                if param == '@phase':
                    global collapsephase
                    collapsephase = str(value)
                    print('collapse phase                   :',collapsephase)

                elif param == '@pval':
                    global collapsepval
                    collapsepval = str(value)
                    print('collapse pval                    :',collapsepval)

                elif param == '@collapsedfile':
                    global collapsefile
                    collapsefile = str(value)
                    print('collapse file                    :',collapsefile)
                
                else:
                    pass

    return None

def extractSeq(reference,PHASList,phasbuff):
    '''
    Extracts PHAS seqeunces from genome, scaffolded genome or transcriptome with buffer of 4 phases + 24-nt;
    writes this slicing coords into a coords file format
    '''

    #### Cache genome - Check for cleaned version of genome, if not produce one in sPARTA folder####
    ####
    fastaclean  = ('%s/%s.clean.fa' % (os.getcwd(),reference.rpartition('/')[-1].rpartition('.')[0]))
    # print(fastaclean)

    if not os.path.isfile(fastaclean) and indexflag == True:
        print("\n#### %s - Reference fasta with clean headers not found" % (fastaclean))
        print("\n#### Reference fasta with clean headers will be generated")
        ### Clean and cache reference
        mode = "0"
        fastaclean,fastasumm,fastaD,fastalenD = FASTAClean(reference,mode)
    
    elif os.path.isfile(fastaclean) and indexflag == False:
        print("\n#### Reference fasta with clean headers located:%s" %  (fastaclean))
        print("Caching reference FASTA")
        ### Cache reference
        fastaD,fastalenD = cacheGenome(fastaclean)
    
    elif os.path.isfile(fastaclean):
        print("** Strange, as you shouldn't have reached to this end of logic")
        print("** There is some problem validating correct reference location")
        print("** Reference file with clean headers located in %s will be used" % (fastaclean))
        print("** You might face some issues in phastrigs run - Keep this message in mind")
        time.sleep(2)
        fastaD,fastalenD = cacheGenome(fastaclean)
    
    else:
        print("** Strange, as you shouldn't have reached to this end of logic")
        print("Script exiting, report issue at: https://github.com/atulkakrana/PHASIS/issues")
        sys.exit()

    #### Get seqeunces for sPARTA analysis
    if runType == 'G' or runType == 'S':
        ### Get PHAS coords file for revampping and seqeunces for sPARTA
        coordfile,seqfile = fetchSequences(fastaD,fastalenD,PHASList,phasbuff)

    elif runType == "T":
        ### Get PHAS transcripts (unique ones)
        coordfile,seqfile = fetchTrans(fastaD,PHASList) ### Coords file is None, as no reverse mapping will be done

    else:
        print("** Invalid @runType value encoutered")
        print("** Please see settings file 'phasis.set' for valid options")
        print("** provide correct @runType value and re-run, script will exit now")
        sys.exit()

    return coordfile,seqfile

def sPARTA(seqfile,mirnafile,parelibs):
    '''
    [--auto mode] Runs sPARTA on extracted coords (runType = 'G' or 'S') and on extracted transcripts (runType = 'T')
    '''

    print("\n#### Fn: sPARTA ##############################")

    #### PREPARE ####
    #################

    ### Put files to sparta analysis folder
    shutil.copy("%s/sPARTA.py" % (phaster_path), "%s/sparta/" % (res_folder)) ### sPARTA script
    shutil.copy("%s" % (mirnafile), "%s/sparta" % (res_folder)) ### miRNA file

    ### Record path and change to sparta analysis folder for analysis
    analysis_path = os.getcwd()                                     ### Record to change later
    sparta_path   = "%s/%s/sparta/" % (os.getcwd(),res_folder)      ### We need to jump to this path temporarily
    os.chdir(sparta_path)
    
    ### Now jump to sparta analysis folder
    print("sPARTA analysis folder:")
    print("%s" % (os.getcwd()))

    ### 
    mirnafile2  = mirnafile                             ### Just file name for sparta analysis (and not full path)
    seqfile2    = "%s" % seqfile.rpartition("/")[-1]    ### Just file name for sparta analysis (and not full path), seqeunce file is already in sparta folder
    # sparta      = "%s/sparta/sPARTA.py" % (res_folder)

    ### Run sPARTA, core settings ####
    ##################################

    ### Just predict targets
    if args.predtype == "P":
        print("Command:")
        print("python3","sPARTA.py", "-featureFile", seqfile2, "-genomeFeature", "0", "-miRNAFile", mirnafile2,"-tarPred", "-tarScore")
        retcode = subprocess.call(["python3","sPARTA.py", "-featureFile", seqfile2, "-genomeFeature", "0","-miRNAFile", mirnafile2,"-tarPred", "E", "-tarScore" ])

    ### Validate targets
    else: 
        ### 1. create soft links of file
        libnameL = [] ### List of PARE libnames
        for alib in parelibs:
            aname = alib.rpartition('/')[-1]
            # print(alib,"%s%s" % (sparta_path,aname))
            os.symlink(alib,"%s/%s" % (sparta_path,aname))       ### dst is current folder which is sPARTA analysis folder
            libnameL.append(aname)

        pareinput = " ".join(libnameL) ### String input for sPARTA
        print("Command:")

        ### Approach-1 - Problem with the parelibs input as sPARTA expects a list from command line, providing list too didn;t worked
        # print("python3","sPARTA.py", "-featureFile", seqfile2, "-genomeFeature", "0", "-miRNAFile", mirnafile2,"-libs", pareinput, "-tarPred", "E", "-tarScore","--tag2FASTA","--map2DD", "--validate")
        # retcode = subprocess.call(["python3","sPARTA.py", "-featureFile", seqfile2, "-genomeFeature", "0","-miRNAFile", mirnafile2, "-libs", pareinput, "-tarPred", "E", "-tarScore","--tag2FASTA","--map2DD", "--validate"])

        #### Approach-2 - Provide command as through shell
        acommand = "python3 sPARTA.py -featureFile %s -genomeFeature 0 -miRNAFile %s -libs %s -tarPred E -tarScore --tag2FASTA --map2DD --validate" % (seqfile2,mirnafile2,pareinput)
        print(acommand)
        retcode = subprocess.call("%s" % (acommand),shell = True )

    if retcode == 0:
        pass
    else:
        print("Problem with Phasing script - Return code not 0")
        sys.exit()


    ### Back to original PATH
    print("## Leaving sPARTA analysis folder:%s" % (sparta_path))
    print("## For original analysis folder:%s" % (analysis_path))
    os.chdir(analysis_path)
    if os.getcwd() == analysis_path:
        print("## Succesfully landed to original analysis folder:%s" % (os.getcwd()))
        print("## Feels like home (back in India)")
    else:
        print("** There were some issues reverting back to original folder:%s" % (analysis_path))
        print("Landed at:%s" % (os.getcwd()))
        print("Somethid is wrong about how $PATHS are configured on your machine")
        print("Please post an issue at: https://github.com/atulkakrana/PHASIS/issues")
        print("Script will exit for now")
        sys.exit()

    return None

def revMapper(ent):

    '''
    Reverse maps coordinates for predicted targets. This is required only in case of predicted targets as validated targets are automatically reverse mapped by sPARTA. The genomic coords for the later are directly read from sPARTA output file
    by the PARE reader.  
    '''
    ## Gene_coords structure: 1, 'c','AT1G01020', 5928, 8737, protein_coding   
    
    # print (ent)
    mir_name  = ent[0]
    gene_name = ent[1]
    bind_site = ent[2].split('-')

    ## Reverse map co-ordinates ##########################################################
    if gene_name in coord_dict_wat:
        # print ('Entry: %s in positive strand: %s' % (ent[0:4],coord_dict_wat[gene_name]))
        geno_start  = coord_dict_wat[gene_name][1]  ## Use for reverse mapping of postive genes
        chr_id      = coord_dict_wat[gene_name][0]
        strand      = 'w'                           ## Available in dictionary also coord_dict_crick[gene_name][1]
        gtype       =  coord_dict_wat[gene_name][2] ## Gene type
        # print("##Info",geno_start,chr_id)
        
        new_bind_site_start = (int(geno_start)-1)+int(bind_site[0]) ### reverified in revFerno - OK
        new_bind_site_end   = (int(geno_start)-1)+int(bind_site[1]) ### reverified in revFerno - OK
        new_bind_site       = '%s-%s' % (new_bind_site_start,new_bind_site_end)

        if args.predtype == "D":
            cleave_site = int(ent[8])
            new_cleave_site     = (int(geno_start)-1)+int(cleave_site)###1 is reduced to give correct positions

    elif gene_name in coord_dict_crick:
        # print ('Entry: %s in reverse strand: %s' % (ent[0:4],coord_dict_crick[gene_name]))
        geno_end    = coord_dict_crick[gene_name][2] ## Use for reverse mapping of negative genes
        chr_id      = coord_dict_crick[gene_name][0]
        strand      = 'c'                            ## Available in dictionary also coord_dict_crick[gene_name][1]
        gtype       =  coord_dict_crick[gene_name][2]## Gene type
        # print("##Info",geno_end,chr_id)

        new_bind_site_end   = (int(geno_end)+1)-int(bind_site[0]) ## As the sequence was reversed before TF and CL, their binding start and end direction has also changed - Verified-OK - reverified in revFerno - OK
        new_bind_site_start = (int(geno_end)+1)-int(bind_site[1]) ### reverified in revFerno - OK
        new_bind_site       = '%s-%s' % (new_bind_site_start,new_bind_site_end)

        if args.predtype == "D":
            cleave_site = int(ent[8])
            new_cleave_site     = (int(geno_end)+1)-int(cleave_site)###1 is added to give correct positions
    
    else:
        print("Gene could not be found in 'w' or 'c' strand - please check if correct value to -coords parameter supplied")
        pass

    if args.predtype == "P":
        # print(" Ent: %s %s %s %s | RevMapped: %s %s %s %s" % (mir_name,gene_name,bind_site[0],bind_site[1],str(chr_id),strand,new_bind_site_start,new_bind_site_end))
        rev_mapped_entry = ("%s,%s,%s,%s,%s" % (','.join(ent),str(chr_id),strand,new_bind_site_start,new_bind_site_end))
    else:
        # print(" Ent: %s %s %s %s %s | RevMapped: %s %s %s %s %s" % (mir_name,gene_name,cleave_site,bind_site[0],bind_site[1],str(chr_id),strand,new_cleave_site,new_bind_site_start,new_bind_site_end))
        rev_mapped_entry = ("%s,%s,%s,%s,%s,%s" % (','.join(ent),str(chr_id),strand,new_cleave_site,new_bind_site_start,new_bind_site_end))


    
    return rev_mapped_entry

def validatePHAS(ent):
    '''
    This function takes one miRNA interation (predicted or validated) and finds matching PHAS
    '''
    
    ## For every interaction 
    #########################
    # print ("\nmiRNA entry being checked as trigger#####################################",ent)
    mirName     = ent[0]
    tarName     = ent[1]
    chrid       = ent[3]
    strand      = ent[4]                ## In case of predicted targets, Inferred from intergenic location using genome DB
    matEnt      = "none"                ## Intialize empty entry
    
    if args.predtype == 'P':
        cleaveSite1,cleaveSite2 = ent[2]## Predicted 10th and 11th as cleave site
        # print("\n-Scanning phased loci for these cleave sites:",mirName,tarName,cleaveSite1,cleaveSite2,chrid,strand)
    else:
        cleaveSite = int(ent[2])        ## PARE supported cleave site
        # print("\n-Scanning phased loci for this cleave site:",mirName,tarName,cleaveSite,chrid,strand)
    
    if revmapflag  == True:            ## targets coordinates match to genome DB i.e. server target analysis was done
        tarStrand   = strand            ## Strand comes from revmapped files
    elif revmapflag == False:
        tarStrand   = "w"
    else:
        print("Don't know which mode it is - Please check 'targetStrand'")
        sys.exit()

    
    ## Dictionary and value for strand offset
    #########################################
    if revmapflag      == True and tarStrand == 'c':                ## Select dict for head or tail scan
        PHASdict        = PHASdict_t    ## Tail scan will be performed
        strandOffVal    = -2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'w' strand
        # print("-miRNA interaction on 'c' strand - tail scan underway")
        # print("-This is the tail coordinates",PHASdict_t)

    elif revmapflag    == True and tarStrand == 'w':              ## Do nothing to cleave site and switch to PHAS dict for tail scan
        PHASdict        = PHASdict_h    ## Head scan will be performed
        strandOffVal    = +2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'c' strand
        # print("-miRNA interaction on 'w' strand - head scan underway")
        # print("-This is the head coordinates",PHASdict_h)
    
    elif revmapflag    == False:
        PHASdict        = PHASdict_h    ## Only head scan will be performed, in -auto mode since both orientations of transcripts are scanned, head and tail ends are checked already
        strandOffVal    = +2            ## Value used for strandOffset list computations i.e. PHAS coordinates correspond to 'c' strand
        # print("-miRNA interaction on 'w' strand - head scan underway")

    else:
        print("-Strand info is non-sense:%s" % (tarStrand))
        sys.exit()


    ## Perform validation
    ############################################
    if args.predtype == 'D':
        ## PHAS LOCI MATCH -  Was not checking for cleave site in exact chromosome - Thats why you got shit load of results where these are scaffolds
        for akey in PHASdict.keys():
            aval = PHASdict[akey]
            # print ('This is the key:', akey, aval)
            if cleaveSite in aval:
                    if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                        # print('-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                        matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite)+1-6)))
                        # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file
                    else:
                        # print ('Cleave site matched phase index but chromosome was different')
                        pass           

            else:
                ## Cleave site doesn't matches as is with phase site, try after factoring dicer- and strand- offsets
                if offset == 1:
                    aval1 = [x+1 for x in aval] ## Dicer Offset - OK
                    aval2 = [x-1 for x in aval] ## Dicer Offset - OK
                    aval3 = [x+strandOffVal for x in aval] ## Strand Offset

                    if cleaveSite in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n- Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval1.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite)+1-6)))
                            # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval1.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file
                    elif cleaveSite in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval2.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite)+1-6)))
                            # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval2.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

                    elif cleaveSite in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            print('\n-Match - miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval3.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite)+1-6)))
                    else:
                        # print ('Cleave site matched phase index but chromosme was different')  
                        pass

                else:
                    print("-Offset checking is OFF")
                    pass

    elif args.predtype == 'P': ## miRFerno results with two possible cleave sites both needs to be checked
        
        for akey in PHASdict.keys():
            aval = PHASdict[akey]
            # print ('This is the key:', akey, aval)
            if cleaveSite1 in aval:
                if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                    # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                    matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite1)+1-6)))

            elif cleaveSite2 in aval:
                if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                    # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                    matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite2)+1-6)))

            
            else: ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
                if offset == 1:
                    aval1 = [x+1 for x in aval] ## Dicer Offset
                    aval2 = [x-1 for x in aval] ## Dicer Offset
                    aval3 = [x+strandOffVal for x in aval] ## Strand Offset
                    
                    ### THIS LOOP CAN BE REDUCED by using a list of cleave sites rather than adding loop everytime - It's a joke
                    if cleaveSite1 in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval1.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt  = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval1:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval1.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite2)+1-6)))
                    
                    elif cleaveSite1 in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval2.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval2:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval2.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite2)+1-6)))

                   
                    elif cleaveSite1 in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval3.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite1)+1-6)))

                    elif cleaveSite2 in aval3:
                        if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
                            # print('-Match: miRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval3.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
                            matEnt = ('%s,%s,%s,so' % (ent[5],akey,(aval3.index(cleaveSite2)+1-6)))

                    else:
                        # print ('Cleave site matched phase index but chromosme was different')  
                        pass
    
    else:
        print("Input correct PARE result type in user settings - Script will exit now")
        sys.exit()


    # ##### LOCAL MODE ###########################################
    # ############################################################
    
    # elif mode == 1: ## Local analysis - Targets are transcripts and no chr_id or strand is required from server

    #     #### PARE validated cleave sites #######################
    #     #######################################################
    #     if PAREresType == 'S' or PAREresType == 'C':
    #         for akey in PHASdict.keys():
    #             aval = PHASdict[akey]
    #             #print ('This is the key:', akey, aval)
    #             if cleaveSite in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. clevage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,akey,aval,(aval.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite)+1-6)))
    #                         # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval.index(cleaveSite)+1-6)))

    #                     else:
    #                         print ('Cleave site matched phase index but chromosme was different')            
    #             else:
    #                 ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
    #                 if offset == 1:
    #                     aval1 = [x+1 for x in aval]
    #                     aval2 = [x-1 for x in aval]
    #                     if cleaveSite in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval1.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite)+1-6)))
    #                             # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval1.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

    #                     elif cleaveSite in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite,tarStrand,akey,aval,(aval2.index(cleaveSite)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite)+1-6)))
    #                             # fh_out.write('%s,%s,%s\n' % (ent[4],akey,(aval2.index(cleaveSite)+1-6))) ## +1 to convert to human readable and -6 to get in reference to phase site in phase file

    #                     else:
    #                         # print ('Cleave site matched phase index but chromosme was different')  
    #                         pass

    #     #### Cleave sites from miRferno #####################
    #     #####################################################
    #     elif PAREresType == 'T':
    #         for akey in PHASdict.keys():
    #             aval = PHASdict[akey]
    #             print ('This is the key:', akey, aval)
    #             # print(cleaveSite1,cleaveSite2)
    #             if cleaveSite1 in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. cleavage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,akey,aval,(aval.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite1)+1-6)))
    #             elif cleaveSite2 in aval:
    #                     if akey.split('-')[0] == chrid: ## i.e. clevage site is on same transcript
    #                         print('\nmiRNA:%s | Target:%s |CleaveSite:%s | PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,akey,aval,(aval.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                         matEnt = ('%s,%s,%s,na' % (ent[5],akey,(aval.index(cleaveSite2)+1-6)))
     
    #             else:
    #                 ## Cleave site doesnt matches with phase site, try (dicer cut) offsets maybe
    #                 if offset == 1:
    #                     aval1 = [x+1 for x in aval]
    #                     aval2 = [x-1 for x in aval]
    #                     if cleaveSite1 in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval1.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite1)+1-6)))
    #                     elif cleaveSite2 in aval1:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval1.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval1.index(cleaveSite2)+1-6)))

    #                     elif cleaveSite1 in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite1,tarStrand,akey,aval,(aval2.index(cleaveSite1)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite1)+1-6)))
    #                     elif cleaveSite2 in aval2:
    #                         if akey.split('-')[0] == chrid: ## i.e. clevage site is on same chromosme
    #                             print('\nmiRNA:%s | Target:%s |CleaveSite:%s | Strand:%s @ PHAS:%s - %s phase: %d' % (mirName,tarName,cleaveSite2,tarStrand,akey,aval,(aval2.index(cleaveSite2)+1-6))) ## 1 added to correct the index in human format and 6 added because start is at 6th postion
    #                             matEnt = ('%s,%s,%s,do' % (ent[5],akey,(aval2.index(cleaveSite2)+1-6)))

    #                     else:
    #                         # print ('No match found even with dicer offsets')  
    #                         pass
        # else:
        #     print("Input correct PARE result type in user settings")
        #     pass

    return matEnt

### HELPER ##################################################
#############################################################

def makePHASList(phase):
    '''
    Creates PHAS lict on fly as required to make search space user tunable
    '''

    ss      = args.searchspace
    aphase  = int(collapsephase)
    ### Create PHAS index ###########################
    print ("Creating dictionary of phased loci")
    if args.predtype == 'D' or args.predtype == 'P':
        # if phase    == 21:
        #     phaseList = [-105,-84,-63,-42,-21,0,21,42,63,84,105,126,147]
        # elif phase  == 24:
        #     phaseList = [-120,-96,-72,-48,-24,0,24,48,72,96,120,144,168]
        # elif phase  == 22:
        #     phaseList = [-110,-88,-66,-44,-22,0,22,44,66,88,110,132,154]
        # else:
        #     print('What the phase for phased loci - Please specify correctly')
        #     sys.exit()

        if aphase >= 21 and aphase <=28:
            phaseList = list(range(-(aphase*ss), (aphase*ss+1), aphase)) ## +1 added to left lim to include the last phase
            print("This is the phaseList",phaseList)
        else:
            print('The phase length %s-nt is not supported - Script will exit' % (aphase))
            sys.exit()
    # sys.exit()

    return phaseList

def PHASreader(PHASfile,collapsephase,phaseList):
    ''' Reads the phased result file
    and creates a dictionary of -5/+7 phased locations as value
    '''

    print("\n#### Fn: PHAS Reader #########################")

    fh_in   = open(PHASfile,'r')
    # PHASres = PHASfile.rpartition("/")[-1]
    # phase   = int(PHASres.rsplit("PHAS")[0][-2:])
    phase   = int(collapsephase)
    header  = fh_in.readline()
    entries = fh_in.readlines()

    PHASdict_h  = {} ## From Head i.e. 5' of PHAS Loci - for head scan
    PHASdict_t  = {} ## From Tail i.e. 3' of PHAS Loci - for tail scan
    PHASdict_b  = {} ## From head and Tail both  i.e.5' and 3' of PHAS Loci - for precursor scan - Not used
    PHASList    = [] ## List to hold PHAS results
    



    ### Parse PHAS results ##########################
    for i in entries:
        if i.strip(): ## Remove an empty line from end file
            aname,apval,achr,astart,aend,trash,alib = i.strip('\n').split('\t')
           
            if runType == 'T':                          ## No reverse mapping means prediction done on transcripts or feature file
                akey ='%s-%s-%s' % (achr.strip(),astart,aend) ## Since its local analysis, transcrpt name would be chr_id - Modfied in v1.14 by removing this part ".split("|")[0]""
            else:
                akey ='%s-%s-%s' % (achr.strip().replace("Chr","").replace("chr",""),astart,aend)
            
            aval_h = [sum(i) for i in zip([int(astart)]*11,phaseList)]
            aval_t = [sum(i) for i in zip([int(aend)]*11,phaseList)]
            # print ("-Key:%s | 5' value: %s | 3' value: %s\n" % (akey,aval_h,aval_t))
            PHASdict_h[akey] = aval_h
            PHASdict_t[akey] = aval_t
            PHASList.append((aname,apval,achr,astart,aend,trash,alib))


            #fh_out.write('%s\t%s\t%s\t%s\t%s\tNONE\tNONE\n' % (phase,pval,chromo.strip(),start,end))##Chromosome has space before it which later gives error while key matching
            #fh_out.write('%s\t%s\n' % (str(akey),str(aval).strip('[]')))

    print("Head dictionary made with entries:%s" % (len(PHASdict_h)))
    print("Tail dictionary made with entries:%s" % (len(PHASdict_t)))

    #### Sanity Check ############################### 
    if len(PHASdict_t) == 0 and len(PHASdict_h) == 0:
        ## Warn user that something is wrong
        print("Head and tail dictionaries are empty - Please check 'pVal' input is correct or troubleshoot")
        print("Script will exit now")
        sys.exit()
    else:
        pass

    # sys.exit()
    fh_in.close()

    return PHASdict_h,PHASdict_t,phase,PHASList

def FASTAClean(filename,mode):
    
    '''
    [Auto mode, indexFlag = True] User specified it's index, headers are processed by phaser-core script. Clean 
    FASTA file to match the treatment done by the phaser core-script i.e. process the identifiers for runType == "G",
    and leave as-is for runType == 'S' and 'T'. This way you will be able to extract cords from cleaned genome using
    phaser coords
    '''
    print("\n#### Fn: FASTAClean ##########################")
    ## Read seqeunce file
    fh_in       = open(filename, 'r')
    # print ("PHASER uses FASTA header as key for identifying the phased loci")
    print ("++ Cleaning header '%s' reference FASTA file" % (filename))
    
    ## Write file
    if mode == 0:
        fastaclean = ('%s/%s.clean.fa' % (os.getcwd(),filename.rpartition('/')[-1].rpartition('.')[0])) ## os.getcwd(),fastaclean.rpartition('/')[-1].rpartition('.')[0]
    else:
        print("Input correct mode- 0: Normal | 1: Seqeunces reversed | 2: Seqeunces reverse complemented | 3: Seqeunces complemented only")
        print("USAGE: cleanFasta.v.x.x.py FASTAFILE MODE")
        sys.exit()

    ### Outfiles
    fh_out1     = open(fastaclean, 'w')
    fastasumm   = ('%s.summ.txt' % (filename.split('.')[0]))
    fh_out2     = open(fastasumm, 'w')
    fh_out2.write("Name\tLen\n")
    
    ### Read files
    fasta       = fh_in.read()
    fasta_splt  = fasta.split('>')

    fastaD      = {}    ## Store FASTA as dict
    fastalenD   = {}    ## Stores chr/scaffold/trans len
    acount      = 0     ## count the number of entries
    empty_count = 0
    for i in fasta_splt[1:]:
        ent     = i.split('\n')
        aname   = ent[0].split()[0].strip() ### Clean 
        
        if runType == 'G':
            ## To match with phasing-core script for genome version which removed non-numeric and preceding 0s
            name = re.sub("[^0-9]", "", aname).lstrip('0') ### Clean and process
        else:
            ## Leave as-is, as phaser-core does not process in runType "S" and "T"
            name = aname
        
        seq     = ''.join(x.strip() for x in ent[1:]) ## Sequence in multiple lines
        alen    = len(seq)
        if alen > 200:
            # fh_out1.write('>%s\n%s\n' % (name,seq)) ### No need to write the file
            # fh_out2.write('%s\t%s\n' % (name,alen)) ### No need to write the file
            fastaD[name]    = seq
            fastalenD[name] = alen 
            acount+=1
        else:
            empty_count+=1
            pass
    
    fh_in.close()
    fh_out1.close()
    fh_out2.close() 

    print("Fasta file with reduced header: '%s' with total entries %s is prepared" % (fastaclean, acount))
    print("There were %s entries found with empty sequences and were removed\n" % (empty_count))
    
    return fastaclean,fastasumm,fastaD,fastalenD

def cacheGenome(fastafile):
    '''
    [mode auto, indexFlag = false]. Reference genome was cleaned and accordinagly processed before phaser run. No processing of chr/trascript names required just cache and run - This module could be merged with FASTA clean as repeated procssing wont affect the analysis.
    '''
    print("\n#### Fn: cacheGenome #########################")

    ### Approach-1 Faster when reading Genome files
    fastaD          = {} ### Dictionary that holds FASTA sequences
    fastalenD       = {}    ## Stores chr/scaffold/trans len

    fh_in           = open(fastafile,'r')
    fasta           = fh_in.read()
    fasta_splt      = fasta.split('>')

    acount          = 0 ## count the number of entries
    empty_count     = 0
    for i in fasta_splt[1:]:
        ent         = i.split('\n')
        name        = ent[0].split()[0].strip()
        # print("++ Caching seqeunce: %s" % (name))

        seq         = ''.join(x.strip() for x in ent[1:]) ## Sequence in multiple lines
        alen        = len(seq)
        if alen > 200:
            acount          +=1
            fastaD[name]    = seq
            fastalenD[name] = alen
        else:
            empty_count+=1
            pass

    # ### Approach-2 - Faster when reading FASTA files fro sRNAs
    # fastaD              = {} ### Dictionary that holds FASTA sequences
    # acount              = 0
    # for line in fh_in:
    #     if line.startswith('>'):
    #       name          = line[1:].rstrip('\n').split()[0]
    #       fastaD[name]  = ''
    #       print("++ Caching seqeunce: %s" % (name))
    #       acount        +=1
    #     else:
    #       fastaD[name]  += line.rstrip('\n').rstrip('*')
    
    # for name,seq in fastaD.items():
    #     print("sequence %s of length %s cached" % (name,alen))

    
    fh_in.close()
    print("Total genome chr/scaffolds cached:%s" % (acount))

    return fastaD,fastalenD

def fetchSequences(fastaD,fastalenD,coordsL,abuff):
    '''
    Fetches and writes seqeunces, and writes a coords file for revferno
    '''
    print("\n#### Fn: fetchSequences ######################")

    coordfile   = "%s/sparta/coords.txt" % (res_folder)
    seqfile     = "%s/sparta/coords.fas" % (res_folder)
    fh_out1     = open(coordfile,'w')
    fh_out2     = open(seqfile,'w')

    coordsL_s   = sorted(coordsL, key=itemgetter(2))    ## Sorts coords on chr to speed up
    cachedchrid = 0                                     ## No chromosome loaded
    
    ####  Load chromosome, extract seqeunce wih flank for 'w' and 'c' strands
    acount  = 0  
    for i in coordsL_s:
        # print("-- Fetching PHAS:",(i))
        aphas,apval,achr,astart,aend,astrand,afile = i ### Chr could be string (scaffols) of digit (genome)
        astart  = int(astart)    ## TO accomodate for python index which start from 0 and not 1
        aend    = int(aend)
        bstart  = astart-abuff  ## Added buffer to seqeunces to identify phasIndex -4 to -1 for 'w' strand, extra buffer on tail below will not be scanned for triggers by revFerno - do not worry
        bend    = aend+abuff    ## Added buffer at tail i.e. head of 'c' strand for phasIndex -4 to -1, extra buffer on tail will not be scanned for trigger by revFerno - do not worry

        if cachedchrid == 0 or cachedchrid != achr:
            ## Load first chromosome, or if chromos0me encoutered is different from the loaded one then load new one
            chrseq          = fastaD[achr]
            cachedchrlen    = fastalenD[achr]
            cachedchrid     = achr              ## Update the chromosome loaded
            print("Loaded Chr:%s    |  Length:%s to memory for slicing" % (achr,len(chrseq)))
            

            ### Coords check
            if bstart   < 1:
                bstart  = 1
                # print("caught")
                # sys.exit()
            if bend     > cachedchrlen:
                bend    = cachedchrlen

            wseq        = chrseq[bstart-1:aend] ## -1 to account for python index which starts from 0 and not 1, no -1 required for end coordinate because slicing will only return end-1, which is precisly your end in python format, 5' flank and no flank on 3'-side
            cseq        = chrseq[astart-1:bend] ## 3' flank and no flank on 5'-side
            # print("++ Sequence fetched for %s length: %s for 'w' and %s for 'c' strand" % (aphas,len(wseq), len(cseq)))
            acount         +=1
            
        elif cachedchrid    == achr:
            ### Uses the loaded chromosome, directly fetch seqeunce


            ### Coords check
            if bstart   < 1:
                bstart  = 1
                # print("caught")
                # sys.exit()
            if bend     > cachedchrlen:
                bend    = cachedchrlen

            wseq        = chrseq[bstart-1:aend] ## 5' ## -1 to account for python index which starts from 0 and not 1, no -1 required for end coordinate because slicing will only return end-1, which is precisly your end in python format, 5' flank and no flank on 3'-side
            cseq        = chrseq[astart-1:bend] ## 3' flank and no flank on 5'-side
            # print("++ Sequence fetched for %s length: %s for 'w' and %s for 'c' strand" % (aphas,len(wseq), len(cseq)))
            acount         +=1


        #### Write seqeunces and coords #######
        ####
        if astrand      == "w":
            wname = "%s_%s_%s_%s_w" % (aphas,achr,bstart,aend) ## Name for coords file
            fh_out1.write("%s,w,%s,%s,%s,gene\n" % (achr,wname,bstart,aend))
            fh_out2.write(">%s\n%s\n" % (wname,wseq))

        elif astrand    == "c":
            cname = "%s_%s_%s_%s_c" % (aphas,achr,astart,bend) ## Name for coords file
            fh_out1.write("%s,c,%s,%s,%s,gene\n" % (achr,cname,astart,bend))
            fh_out2.write(">%s\n%s\n" % (cname,cseq[::-1].translate(str.maketrans("tagcTAGC","atcgATCG"))))

        elif astrand    == "NONE":
            ### phaser results have NONE for strand, write both strands
            wname = "%s_%s_%s_%s_w" % (aphas,achr,bstart,aend) ## Name for coords file
            cname = "%s_%s_%s_%s_c" % (aphas,achr,astart,bend) ## Name for coords file

            fh_out1.write("%s,w,%s,%s,%s,gene\n" % (achr,wname,bstart,aend))
            fh_out1.write("%s,c,%s,%s,%s,gene\n" % (achr,cname,astart,bend))
            
            fh_out2.write(">%s\n%s\n" % (wname,wseq))
            fh_out2.write(">%s\n%s\n" % (cname,cseq[::-1].translate(str.maketrans("tagcTAGC","atcgATCG"))))
        
        else:
            print("** Unexpected strand encountered:%s" % (astrand))
            print("** Please check the '*collapsed.txt' results file from 'collapser' analysis")
            print("** Script will exit now")
            sys.exit()

    fh_out1.close()
    fh_out2.close()

    print("PHAS entries:%s | Seqeunces extracted:%s" % (len(coordsL),acount))

    return coordfile,seqfile

def fetchTrans(fastaD,coordsL):
    '''
    Fetches transcripts from transcriptome FASTA, sice it's the real trnscript, no revrse mapping will be done so not coords file generated like the getchSeqeunces function
    '''

    print("\n#### Fn: fetchTrans ##########################")

    coordsfile  = None
    seqfile     = "%s/sparta/trans.fas" % (res_folder)
    fh_out      = open(seqfile,'w')

    transset    = set()
    acount      = 0
    for i in coordsL:
        # print(i)
        aphas,apval,achr,astart,aend,astrand,afile = i

        if achr not in transset:
            ### This will avoid writing the same transcript twice if it had two PHAS
            # print(achr)
            aseq = fastaD[achr] ### chromosome is transcripts ID
            fh_out.write(">%s\n%s\n" % (achr,aseq))
            transset.add(achr)
            acount += 1

    print("PHAS entries:%s | Unique trans written:%s" % (len(coordsL),acount))

    fh_out.close()

    return coordsfile,seqfile

def formatguess(alib):
    '''
    guesses the format od seqeunce-based file
    '''
    print("\n#### Fn: formatguess #########################")
    ### Cache firs two lines
    fh_in       = open(alib,'r')
    firstline   = fh_in.readline().strip("\n").strip()
    secondline  = fh_in.readline().strip("\n").strip()
    fh_in.close()


    formatflag = ''
    if (firstline.startswith('>') and len(firstline.split('\t')) < 2) and (not secondline.startswith('>') and len(secondline.split('\t')) < 2):
        print("File %s seems to be in FASTA format" % (alib))
        formatflag = 'fas'

    elif len(firstline.split('\t')) == 2 and len(secondline.split('\t')) == 2:
        if firstline.split('\t')[1].isnumeric():
            print("File %s seems to be in counts format" % (alib))
            formatflag = 'count'
    else:
        print("Unknown format for PARE/degradome data")
        print("phastrigs might exit with error")
        pass

    return formatflag

def parsePredicted(predTarF):
    '''
    parses mirferno results for reverse mapping,module is PATH resistant i.e. if filename has lonh PATH it wont affect 
    analysis
    '''

    print("\n#### Fn: miRferno Parser #####################")
    print("Reading '%s' file from folder" % predTarF)
    
    predTarL    = []                        ## list of final results or parlist
    acount      = 0                         ## All entries
    bcount      = 0                         ## That passed user provided score cutoff

    fh_in       = open("%s" % predTarF, 'r')    ## PARE VALIDATED results
    predheader  = fh_in.readline()              ## waste header
    aread       = fh_in.readlines()
    
    acount      = 0

    for res in aread:
        ent    = res.strip('\n').split(',')
        if ent[0] == "miRname":
            # print("Header left in concatanated file")
            pass
        else:
            acount      +=1
            if float(ent[5]) <= args.score:
                predTarL.append(ent)
                bcount+= 1
            else:
                # print("Below user provides score threshold")
                pass
    
    print("Total entries in predicted file:%s | Passed user threshold:%s" % (acount,bcount))
    fh_in.close()

    return predTarL,predheader

def tarReader(PAREres,PAREpval):
    '''
    Reads predicted or validated file from sPARTA. In case of degradome validated output from sPARTA, no reversemapping is performed by revFerno but it is checked whether these are from genomic analysis or transcriptome analysis (using 
    featureFile). As, in later local coordinates will be read while in earlier revmapped coordinates in sPARTA output
    will be read. On other hand, in case of predicted same thing is checked if predicted results are from genomic analysis
    in which reverse mapping will be performed by reverFerno while in case of predicted results from being transcriptome
    analysis reverse mapping is skipped and local coords read.   
    '''


    ########## ADD IF LOOP FOR runTYPE = 'G', THEIR CHROMOSOME ENTRIES NEED TO BE PROCESSED #########

    print("\n#### Fn: Targets Reader ######################")
    
    fh_in   = open(PAREres, 'r')
    header  = fh_in.readline() ## Header
    entries = fh_in.readlines()
    acount  = 0  ## Total entries
    bcount  = 0  ## Filtered entries on targetScore (predicted) or p-value (validated)
    resList = [] ## miRNA,Target,cleavesite,whole entry
    # print ("\n\n\nCreating list of cleave sites\n")

    if args.predtype == 'D' and revmapflag == False: ## Degradome validation done but using transcripts i.e. feature file option. No reverse mapping performed and columns in validated output would be different
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount      += 1  ## Total entries
            ent_splt    = i.split(',')
            #print("\nThis is target entry",ent_splt[13])
            if float(ent_splt[14])  <= PAREpval:
                cleaveSite          = int(ent_splt[8])
                #print(cleaveSite)
                tarName = ent_splt[1]
                mirName = ent_splt[0]
                chrid   = ent_splt[1] ## In local mode (When feature file used) there is no chr_id, only transcripts
                strand  = 'None'
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print(mirName,tarName,cleaveSite)
                bcount += 0
    

    elif args.predtype == 'D' and revmapflag == True: ## Degradome validation done using genome, validated file will have revmapped targets 
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount      += 1  ## Total entries
            ent_splt    = i.split(',')
            # print("\nThis is target entry p-val:",ent_splt[13])
            if float(ent_splt[13])  <= PAREpval:
                cleaveSite          = int(ent_splt[17])
                #print(cleaveSite)
                mirName = ent_splt[0]
                tarName = ent_splt[1]
                chrid   = ent_splt[15]
                strand  = ent_splt[16]
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("\nList values for this entry",mirName,tarName,cleaveSite,chrid,strand,i.strip('\n'))
                bcount += 1


    elif args.predtype == 'P' and revmapflag == False: ## miRferno was run using feature file option i.e. directly on transcriptome, so no reversmapping done or needs to be done in revFerno or sPARTA
        for i in entries:
            print ("\nEnt:",i.strip('\n'))
            acount += 1  ## Total entries
            ent_splt = i.strip('\n').split(',')
            # print("\nThis is target entry",ent_splt)
            if float(ent_splt[5])   <= args.score:
                bindStart,bindEnd   = ent_splt[2].split("-")
                cleaveSite1         = int(bindEnd)-10+1 ## 10th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                cleaveSite2         = int(bindEnd)-11+1 ## 11th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                # cleaveSite3 = int(bindEnd)-12+1 ## 12th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct ## Added after observing that 2275 cleaves a major portion at 13th pos
                # cleaveSite4 = int(bindEnd)-13+1 ## 13th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                cleaveSite          = (cleaveSite1,cleaveSite2)
                # print(cleaveSite)
                mirName             = ent_splt[0]
                tarName             = ent_splt[1]
                chrid               = ent_splt[1] ## In local mode there is no chr_id, only transcripts
                strand              = 'None'
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("List values for this entry",mirName,tarName,cleaveSite,chrid,i.strip('\n'))
                bcount += 1



    elif args.predtype == 'P' and revmapflag == True: ## miRferno predicted targets using the genome and revmapping was done in revFerno above
        for i in entries:
            # print ("\nEnt:",i.strip('\n'))
            acount += 1  ## Total entries
            ent_splt    = i.strip('\n').split(',')
            chrid       = ent_splt[8] ## In local mode there is no chr_id, only transcripts
            strand      = ent_splt[9]
            # print("\nThis is target entry",ent_splt)
            if float(ent_splt[5]) <= args.score:
                # print("pass")
                bindStart   = ent_splt[10]
                bindEnd     = ent_splt[11]
                if strand == "c":
                    ## This is to accomodate 13th position validation observed for 'c' strand
                    cleaveSite3 = int(bindEnd)-12+1 ## 12th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct ## Added after observing that 2275 cleaves a major portion at 13th pos
                    cleaveSite4 = int(bindEnd)-13+1 ## 13th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite  = (cleaveSite3,cleaveSite4)
                else:
                    ## Watson strand
                    cleaveSite1 = int(bindEnd)-10+1 ## 10th pos +1  - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite2 = int(bindEnd)-11+1 ## 11th pos +1 - tested and corrected - Draw a miRNA-target interaction and try computing - This is correct
                    cleaveSite  = (cleaveSite1,cleaveSite2)
                # print(cleaveSite)
                mirName     = ent_splt[0]
                tarName     = ent_splt[1]
                resList.append((mirName,tarName,cleaveSite,chrid,strand,i.strip('\n')))
                # print("List values for this entry:",mirName,tarName,cleaveSite,chrid)
                bcount += 1
        
    else:
        pass

    print("Input file:%s" % (PAREres))
    print("File entries:%s | Passed p-val/score:%s | List length:%s" % (acount,bcount,len(resList)))
    
    return resList,header

def processTarCoords(resList):
    '''
    [mode manual, indexFlag = False and True] Additional procesing of coordinates required to improve compatibility of user-supplied index used for PHAS loci
    prediction or if user supplied it's own miRNA targets - See decision map in onenote 'maps'
    '''
    if args.mode == 'man':
        
        if indexflag == True and runType == "G":
            ### User supplied index used by phaser, which is processed to digits by phaser-core. To make targets predicted by user using genome with orginal chrid comaptible with phaser results, process the targets chromosome ids
            for res in reslist:
                chrid = re.sub("[^0-9]", "", res[3]).strip('0') ## requires only processing, as reference is not cleaned
                res[3] = chr_id

        
        elif indexflag == False and runType == "G":
        ### User supplied sPARTA predicted and validated results to be used, and these must have been generated using
        #### un-clean reference file. Expect results to be cleaned by sPARTA but for runType "G" these needs
        #### the chromosome id needs to just have digits to match phaser results
            for res in reslist:
                chrid = re.sub("[^0-9]", "", res[3]).strip('0') ## requires only cleaning and processing, as reference is cleaned by phaser, but these results are already cleaned by sPARTA, now this 'elif' can be merged with 'if' above
                res[3] = chr_id

        else:
            ## No need for auto mode as for that modifications are made 
            ## at the time of extracting coords
            pass

    return resList

def prepareCoordsDict(coordsfile):

    '''
    Prepares global dictionary of coords file for reverse mapping
    '''
    print("\n#### Fn: Coords Dict Maker ###################")

    ### GET COORDS #####################################
    fh_in       = open(coordsfile,"r")
    fileRead    = fh_in.readlines()
    coords      = [] ## List to store coords

    for i in fileRead:
        ent     = i.strip("\n").split(",")
        # print("This is read entry",ent)
        coords.append((ent))
    print("Coords read from file:%s entries" % (len(coords)))
    # print("Step 1/4: DONE!!\n\n")

    ####  PREPARE DICTIONARY OF COORDS ########################################
    # print("Step 2/4: Preparing dictionary of coordinates")

    global coord_dict_wat, coord_dict_crick
    coord_dict_wat      = {} ## Dictionary of genes at watson strand, +
    coord_dict_crick    = {}###Dictionary of genes at crick strand, - strand
    # shutil.rmtree("./%s" % (res_folder), ignore_errors=True) ## AK Added 
    # os.mkdir("./%s" % (res_folder)) ## AK added

    # global nproc
    # nproc ='1' ## Need better handling

    for i in coords:### gene_coords is a list in script, also written out as file of same name
        # print ("This is a coord:",i)
        # strand = i.split(',')[1] for file  ###TEST if reading from file
        strand = i[1]
        if strand == 'c':### if entry in reverse strand
            atuple = (i[0],i[3],i[4],i[5])
            # print("c:",atuple)
            coord_dict_crick[i[2]] = atuple ## Gene name as key and chr_id,start,end and gene type as value
        elif strand == 'w':
            atuple = (i[0],i[3],i[4],i[5])
            # print("w:",atuple)
            coord_dict_wat[i[2]] = atuple   ## Gene name as key and chr_id,start,end and gene type as value
            # print (atuple)
        else:
            print("** Error preparing dictionary for rev mapping")
            print("** Unrecognized strand:%s" % (strand))
            print("** You can post a query at: https://github.com/atulkakrana/PHASIS/issues")
            print("** Script will exit now")
            sys.exit()

        
    print("Strand dictionary made with %s and %s entries in 'w' and 'c' strand dictionaries" % (len(coord_dict_wat),len(coord_dict_crick)))
    # print("Step 2/4: DONE!!\n\n")
    # sys.exit()

    return None

def revmapWriter(revmapL,predheader,afile):
    '''
    writes results from reverse mapping. Function is PATH aware
    '''
    print("\n#### Fn: revMap Writer #######################")

    if args.mode == "auto":
        revmapF     = '%s_revmapped.csv' % (afile) ### args.predfile is a relative PATH in --auto mode
    else:
        revmapF     = './%s/%s_revmapped.csv' % (res_folder,afile)
    
    fh_out      = open(revmapF, 'w')
    if args.predtype == "D":
        fh_out.write('%s,Chr,Strand,GenomicCleaveSite,GenomicBindStart,GenomicBindEnd\n' % (predheader.strip('\n')))
    else:
        fh_out.write('%s,Chr,Strand,GenomicBindStart,GenomicBindEnd\n' % (predheader.strip('\n')))

    for i in revmapL: ## Write Results from list to file
        if i != 'E13-3-13':##Filter for error 13-13-13 that is small window abundance = 0 and ratio calculation error
            fh_out.write('%s\n' % (i))
        else:
            print (i)
            pass

    fh_out.close()

    return revmapF

def revfernoWriter(validPHAS,resList,PHASdict_h,afile):

    '''
    Writes validated PHAS results 
    '''
    print("\n#### Fn: revFerno Writer #####################")
    
    ## Write results
    validphasF  = './%s/%s_trigger.csv' % (res_folder,afile.rpartition("/")[-1])
    fh_out      = open(validphasF,'w')
    fh_out.write('%s,PHASLoci,PHASindex,matFlag\n' % (header.strip('\n')))
    
    acount = 0 ## Matched count
    for i in validPHAS:
        if i != "none":
            fh_out.write("%s\n" % (i))
            acount +=1
    fh_out.close()

    print("Total entries in triggers list:%s | Entries in PHAS dict: %s" % (len(resList),len(PHASdict_h)))
    print("Matched (triggers might be redundant for same PHAS loci):%s" % (acount))

    return validphasF

def PP(module,alist):
    print('***********Parallel instance of %s is being executed*********' % (module))
    
    start = time.time()
    ##PP is being used for Bowtie mappings - This will avoid overflooding of processes to server
    nprocPP = round((nproc/int(nthread))+1) ## 1 added so as to avoid 0 processor being allocated in serial mode
    print('\nnprocPP:%s\n' % (nprocPP))
    npool = Pool(int(nprocPP))
    npool.map(module, alist)

def PPmultiple(module,alist1,alist2):
    start = time.time()
    npool = Pool(int(nproc))
    npool.map(lambda args: module(*args), alist2)

def PPResults(module,alist):
    npool = Pool(int(nproc))    
    res = npool.map_async(module, alist)
    if(res.get() == []):
        print("YEP!")
    results = (res.get())
    npool.close()           ### Added by Reza to close hanging 
    return results

#### DE-DUPLICATOR MODULES ####
def dedup_process(alib):
    '''
    To parallelize the process
    '''
    print("\n#### Fn: De-duplicater #######################")

    afastaL     = dedup_fastatolist(alib)         ## Read
    acounter    = deduplicate(afastaL )            ## De-duplicate
    countFile   = dedup_writer(acounter,alib)   ## Write

    return countFile

def dedup_fastatolist(alib):
    '''
    New FASTA reader
    '''

    ### Sanity check
    try:
        f = open(alib,'r')
    except IOError:                    
        print ("The file, %s, does not exist" % (alib))
        return None


    ## Output 
    fastaL      = [] ## List that holds FASTA tags

    print("Reading FASTA file:%s to convert to counts format" % (alib))
    read_start  = time.time()
    
    acount      = 0
    empty_count = 0
    for line in f:
        if line.startswith('>'):
            seq = ''
            pass
        else:
          seq = line.rstrip('\n')
          fastaL.append(seq)
          acount += 1

    read_end    = time.time()
    # print("-- Read time: %ss" % (str(round(read_end-read_start,2))))
    print("Cached file: %s | Tags: %s | Empty headers: %ss" % (alib,acount,empty_count)) 

    return fastaL
                   
def deduplicate(afastaL):
    '''
    De-duplicates tags using multiple threads and libraries using multiple cores
    '''
    dedup_start  = time.time()

    # deList = [] ## Hold deduplicated tags and their abudnaces in a tuple

    acounter    = collections.Counter(afastaL)

    dedup_end  = time.time()
    # print("-- dedup time: %ss" % (str(round(dedup_end-dedup_start,2))))

    return acounter 

def dedup_writer(acounter,alib):
    '''
    writes tag count or de-duplicated FASTA to a a file in same directory. PATH AWARE i.e. safe if user supplies libraries stored in a different folder - The results would be current folder
    '''
    print("Writing counts file for %s" % (alib))
    outpath     = os.getcwd()                                                   ### Path to write file
    outname     = "%s.txt" % (alib.rpartition('/')[-1].rpartition('.')[0])      ### Name of file
    countFile   = "%s/%s" % (outpath,outname)                                   ### Full file address
    fh_out      = open(countFile,'w')
    print("File path:%s" % (outpath))

    acount      = 0
    # seqcount    = 1 ## TO name seqeunces
    for i,j in acounter.items():
        fh_out.write("%s\t%s\n" % (i,j)) ### Tag count format
        # fh_out.write(">seq_%s|%s\n%s\n" % (seqcount,j,i)) ### de-duplicated fasta format
        acount      += 1
        # seqcount    += 1

    print("Total unique entries written for %s: %s" % (alib,acount))

    fh_out.close()

    return countFile

### MAIN ####################################################
#############################################################

def main():

    ### PREPARE ########
    ####################

    ### Read settings and memory file
    checkDependency()
    libs        = readSet(setFile)
    collpasemem = "%s/%s" % (args.dir,memFile)
    readMem(collpasemem)

    ### Global variables
    global revmapflag
    global indexflag
    global PHASdict_h
    global PHASdict_t
    global PHASdict_b
    global header
    
    ### Reverse mapping to be done or not by revferno - See decision map in onenote 'maps'
    if args.mode    == 'auto' and runType  == "T": ## Transcriptome does not requires revmapping
        revmapflag  = False
    elif args.mode  == 'man'  and runType  == "T": ## Transcriptome does not requires revmapping
        revmapflag  = False
    elif (args.mode  == 'man') and (runType == 'G' or runType == 'S') and (args.predtype == 'D'): ## If reference is genome or scaffold and results are predicted ones then not need
        revmapflag  = False
    else:
        revmapflag  = True

    ### User supplied identfiers needs processing or not - See decision map in onenote 'maps'
    if index.strip():
        ### User supplied index, user supplied target identifiers needs processing
        indexflag   = True
    else:
        ### A full phaser run, FASTA header cleaned and processed accordingly, generally identifiers don't need processing
        indexflag   = False 

    
    ### Make results folders  
    shutil.rmtree("%s" % (res_folder),ignore_errors=True) ## Delete if exists same folder name - Not possible in real runs
    os.mkdir("%s" % (res_folder))
    if args.mode == 'auto':
            ### Make a folder for sPARTA analysis
            shutil.rmtree("%s/sparta" % (res_folder),ignore_errors=True)
            os.mkdir("%s/sparta" % (res_folder))

    ### PREPARE TARGETS - AUTO MODE ###############
    ###############################################
    if args.mode == "auto":

        ### PHAS coords
        PHASfile    = "%s/%s" % (args.dir,collapsefile.rpartition("/")[-1])
        phaseList   = makePHASList(collapsephase)
        PHASdict_h,PHASdict_t,phase,PHASList = PHASreader(PHASfile,collapsephase,phaseList)

        ### Extract genome coords and PHAS transcripts or transcripts from transcriptome
        phasbuff                = int(phase)*int(args.searchspace)+int(collapsephase) ## Flaking buffer to add to the extracted PHAS transcript for runType = 'G' and 'S', added an extra phase to make sure that left most PHAS-index has space to map miRNA
        coordsfile,extractseq   = extractSeq(reference,PHASList,phasbuff) ## runType aware
        
        ### Run sPARTA 
        if args.predtype        == "P":
            # print("#### Trigger validation will be done based on predicted targets")
            ## No PARE libraries, so just predict targets
            parelibs            = None                 ### No PARE libraries
            sPARTA(extractseq,args.mir,parelibs)
        else:
            ## Prepare PARE libraries and copy to sPARTA
            # print("#### Trigger validation will be done based on validated targets")
            # userlibs            = args.libs
            formatflag          = formatguess(args.libs[0])                ### Guess format for PARE files that user provides
            if formatflag       == "fas":               
                parelibs        = PPResults(dedup_process,args.libs)       ### Converted to tag-count
                sPARTA(extractseq,args.mir,parelibs)                    ### Run sPARTA on converted files
            elif formatflag     == "count":
                parelibs        = ["%s/%s" % (os.getcwd(),alib) for alib in args.libs] ## Matches with dedup results
                sPARTA(extractseq,args.mir,parelibs)                    ### Run sPARTA on tag count files directly
                
        
        predTarL,predheader     = parsePredicted(args.predfile) ### args.predfile path is filled in arguments section
        
        if runType == 'G' or runType == 'S' and revmapflag == True:
            ### Reverse Map the predicted or validated results
            prepareCoordsDict(coordsfile) ### Prepare coords dict
            
            print("\n#### Fn: revMapper ########################")
            # ### TEST - Serial Mode #######
            # print('\n***Entering RevMapCoord- Serial***\n')
            # revmapL = []
            # for i in predTarL:
            #     # print("\nEntry for reverse mapping:%s" % (i))
            #     z = revMapper(i)
            #     revmapL.append(z)
            revmapL         = PPResults(revMapper, predTarL) ## Results are in form of list
            # print('Reverse mapping complete for:%s' % (args.predfile))
            # time.sleep(1)

            revmapF         = revmapWriter(revmapL,predheader,args.predfile)
            resList,header  = tarReader(revmapF,PAREpval)      ### Reads reverse mapped file - Are columns same as PARE file?

        elif runType == 'T' and revmapflag == False:
            ### No reverse mapping required
            resList,header  = tarReader(args.predfile,PAREpval)

        else:
            print("** Issues deciding which way to go from here - unexpected logic encountered")
            print("** You could have input invalid value for @runType parameter in 'prepro.set' file")
            print("** Please check the description for @runType parameter in 'prepro.set' file")
            print("** If all looks good from your side then developer needs to be informed: https://github.com/atulkakrana/PHASIS/issues")
            print("** Script will exit now - Sorry")
            sys.exit()


    ### PREPARE TARGETS - MANUAL MODE #############
    ###############################################
    if args.mode == "man":

        ### PHAS coords
        PHASfile    = "%s/%s" % (args.dir,collapsefile.rpartition("/")[-1])
        phaseList   = makePHASList(collapsephase)
        PHASdict_h,PHASdict_t,phase,PHASList = PHASreader(PHASfile,collapsephase,phaseList)

        ### Reverse mapping
        if args.predtype == "P" and revmapflag == True:
            
            ### GET COORDS ####
            prepareCoordsDict(args.coord)
            predTarL,predheader = parsePredicted(args.predfile)        
            
            ### REVERSE MAP ####
            print("\n#### Fn: Reverse Mapper ####################") 
            
            #### TEST - Serial Mode #######
            # print('\n***Entering RevMapCoord- Serial***\n')
            # revmapL = []
            # for i in predTarL:
            #     # print("\nEntry for reverse mapping:%s" % (i))
            #     z = RevMapCoord(i)
            #     revmapL.append(z)
            
            ### Default - parallelized mode - uncomment serial mode above after testing
            print('***Entering RevMapCoord- parallel***')
            revmapL = PPResults(revMapper, predTarL) ## Results are in form of list
            print('Reverse mapping complete for:%s' % (args.predfile))
            time.sleep(1)

            revmapF         = revmapWriter(revmapL,predheader,args.predfile)
            resList,header  = tarReader(revmapF,PAREpval)      ### Reads reverse mapped file - Are columns same as PARE file?
            resList         = processTarCoords(resList)

        else:
            resList,header  = tarReader(args.predfile,PAREpval) ### Reads PARE file
            resList         = processTarCoords(resList)

    #### Predict triggers ##########################
    ################################################
    if args.dir is not "":
        
        print("\n#### Fn: Trigger Predictor #################")
        #### TEST - Serial Mode #######
        # validPHAS = [] ## Store results
        # for i in resList:
        #     matEnt = validatePHAS(i)
        #     validPHAS.append(matEnt)

        ### DEFAULT - parallelized mode - uncomment serial mode above after testing ##
        validPHAS   = PPResults(validatePHAS,resList) ## Results are in form of list
        validphasF  = revfernoWriter(validPHAS,resList,PHASdict_h,args.predfile)

    else:
        pass

if __name__ == '__main__':

    if nproc == 'Y':
        nproc = int(multiprocessing.cpu_count()*0.80)
    else:
        nproc == int(nproc)
    start = time.time()
    main()
    end = time.time()
    print('\nThe run has completed sucessfully')
    print('Complete run time is %ss\n' % (round(end-start,2)))
    sys.exit()


## v01
## Written to revmap internal mirFErno predicted targets

## v01 -> v02 [stable] [Nov-4-2015]
## Added compatibility to sPARTAv1.16 and above
## Modifed user input - now afile is provided for reverse mapping instead of lookup in folder
## Improved user experienece stuff, cleaned up the script

## v09 -> v095
## Renamed args.pred to args.predfile
## Added 'required' category to args.parse

## v095 -> v099 [major]
## Added --auto mode
## Argument parser updated for auto mode
## runType updates for 'G', 'T' and 'S'
## Fixed reversemapping error - No valid triggers were being found at 'c' strand - In reverse mapping 
#### function for crick strand genomic start site was beng used instead of genomic end to compute 
#### new coordinates - Fixed by replacing geno_end    = coord_dict_crick[gene_name][1] with
#### geno_end    = coord_dict_crick[gene_name][2] -  see the difference in coordinates
## sPARTA turned to exhaustive mode
## sPARTA is working on multiple PARE libraries now 
## Added functionality to validate targets automatically

## v099 -> v1.0 [major]
## Fixed issues related with runType mode "T"

## v1.0 -> v1.01 [stable]
## Added sanity to checks to readset function

## v1.01 -> v1.02
## Renamed to PHASIS

## v1.02 -> v1.03
## Added option 'searchspace' to specify PHAS index to scan
## To work with this option the value of PHASbuff is make dynamic too, plus an
#### extra phase added while extracting seqeunce so that the Pas-index at corners
#### can fit miRNA site


#### POTENTIAL ISSUES
## 1. If a user uses his own index which is made from un-clean FASTA file. In that case.
#### no clean fasta file will be located and will be made by revferno. This cleaned up file
#### will be used for target prediction in which case headers or name of targets will be
#### different and won't match up. Therefore no PHAS will be validated - Ask USERS to do a
#### full run i.e. do not use their index instead make it through PHASER i.e. leave #index 
#### settings empty in settings file


